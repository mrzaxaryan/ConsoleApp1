using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using static ConsoleApp1.X64Emulator;
using static VectoredExceptionHandler;
unsafe class Program
{
    static byte[] Build(int stackSize)
    {
        var b = new List<byte>(64);

        // prologue
        b.AddRange(new byte[] { 0x55, 0x48, 0x89, 0xE5 });

        // sub rsp, imm32
        b.AddRange(new byte[] { 0x48, 0x81, 0xEC });
        b.AddRange(BitConverter.GetBytes(stackSize)); // 00 80 00 00 for 0x8000

        // mov dword ptr [rbp-4], 5
        b.AddRange(new byte[] { 0xC7, 0x45, 0xFC, 0x05, 0x00, 0x00, 0x00 });

        // xor rcx, rcx
        b.AddRange(new byte[] { 0x48, 0x31, 0xC9 });

        // mov byte ptr [rbp+rcx+disp32], 0   (disp32 = -stackSize)
        b.AddRange(new byte[] { 0xC6, 0x84, 0x0D });
        b.AddRange(BitConverter.GetBytes(unchecked((int)-stackSize))); // 00 80 FF FF for 0x8000
        b.Add(0x00); // imm8

        // inc rcx
        b.AddRange(new byte[] { 0x48, 0xFF, 0xC1 });

        // cmp rcx, imm32
        b.AddRange(new byte[] { 0x48, 0x81, 0xF9 });
        b.AddRange(BitConverter.GetBytes(stackSize));

        // jb short -0x14
        b.AddRange(new byte[] { 0x72, 0xEC });

        // mov eax, ecx ; add eax, [rbp-4] ; epilogue
        b.AddRange(new byte[] { 0x8B, 0xC1, 0x03, 0x45, 0xFC, 0x48, 0x89, 0xEC, 0x5D, 0xC3 });

        return b.ToArray();
    }
    [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
    static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

    [DllImport("kernel32.dll")]
    static extern bool GetThreadContext(IntPtr hThread, IntPtr ctx);

    [DllImport("kernel32.dll")]
    static extern bool SetThreadContext(IntPtr hThread, IntPtr ctx);

    [DllImport("kernel32.dll")]
    static extern IntPtr GetCurrentThread();
    //GetLastError
    [DllImport("kernel32.dll")]
    static extern uint GetLastError();
    delegate UInt32 HashPrototype();
    static void Main()
    {
        byte[] code = File.ReadAllBytes("64.bin");

        byte[] code2 = Build(1024 * 16);
        
        byte[] code3 = { 0x55, 0x48, 0x89, 0xE5, 0x48, 0x83, 0xEC, 0x70, 0xB8, 0x60, 0x00, 0x00, 0x00, 0x65, 0x48, 0x8B, 0x00, 0x48, 0x89, 0x45, 0xF8, 0x48, 0x8B, 0x45, 0xF8, 0x48, 0x8D, 0x15, 0xB0, 0x03, 0x00, 0x00, 0x48, 0x89, 0xC1, 0xE8, 0xA8, 0x00, 0x00, 0x00, 0x48, 0x89, 0x45, 0xF0, 0x48, 0x83, 0x7D, 0xF0, 0x00, 0x75, 0x0A, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0xE9, 0x91, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x45, 0xF0, 0x48, 0x8D, 0x15, 0xA2, 0x03, 0x00, 0x00, 0x48, 0x89, 0xC1, 0xE8, 0x10, 0x01, 0x00, 0x00, 0x48, 0x89, 0x45, 0xE8, 0x48, 0x83, 0x7D, 0xE8, 0x00, 0x75, 0x07, 0xB8, 0xFF, 0xFF, 0xFF, 0xFF, 0xEB, 0x6C, 0xC6, 0x45, 0xDA, 0x48, 0xC6, 0x45, 0xDB, 0x65, 0xC6, 0x45, 0xDC, 0x6C, 0xC6, 0x45, 0xDD, 0x6C, 0xC6, 0x45, 0xDE, 0x6F, 0xC6, 0x45, 0xDF, 0x20, 0xC6, 0x45, 0xE0, 0x57, 0xC6, 0x45, 0xE1, 0x6F, 0xC6, 0x45, 0xE2, 0x72, 0xC6, 0x45, 0xE3, 0x6C, 0xC6, 0x45, 0xE4, 0x64, 0xC6, 0x45, 0xE5, 0x21, 0xC6, 0x45, 0xE6, 0x0A, 0xC6, 0x45, 0xE7, 0x00, 0x48, 0x8B, 0x45, 0xF8, 0x48, 0x8B, 0x40, 0x20, 0x48, 0x8B, 0x48, 0x28, 0x48, 0x8D, 0x45, 0xDA, 0x48, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x55, 0xE8, 0x41, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x41, 0xB8, 0x0E, 0x00, 0x00, 0x00, 0x48, 0x89, 0xC2, 0x41, 0xFF, 0xD2, 0xB8, 0x00, 0x00, 0x00, 0x00, 0xC9, 0xC3, 0x55, 0x48, 0x89, 0xE5, 0x48, 0x83, 0xEC, 0x40, 0x48, 0x89, 0x4D, 0x10, 0x48, 0x89, 0x55, 0x18, 0x48, 0x8B, 0x45, 0x10, 0x48, 0x8B, 0x40, 0x18, 0x48, 0x8B, 0x40, 0x20, 0x48, 0x89, 0x45, 0xF8, 0x48, 0x8B, 0x45, 0xF8, 0x48, 0x89, 0x45, 0xF0, 0x48, 0x8B, 0x45, 0xF8, 0x48, 0x89, 0x45, 0xE8, 0x48, 0x8B, 0x45, 0xE8, 0x48, 0x8B, 0x40, 0x50, 0x48, 0x85, 0xC0, 0x74, 0x40, 0x48, 0x8B, 0x45, 0xE8, 0x48, 0x8B, 0x40, 0x50, 0x48, 0x8B, 0x55, 0x18, 0x48, 0x89, 0xC1, 0xE8, 0x1F, 0x01, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x0A, 0x48, 0x8B, 0x45, 0xF8, 0x48, 0x8B, 0x40, 0x20, 0xEB, 0x24, 0x48, 0x8B, 0x45, 0xF8, 0x48, 0x8B, 0x00, 0x48, 0x89, 0x45, 0xF8, 0x48, 0x83, 0x7D, 0xF8, 0x00, 0x74, 0x0D, 0x48, 0x8B, 0x45, 0xF8, 0x48, 0x3B, 0x45, 0xF0, 0x75, 0xAD, 0xEB, 0x01, 0x90, 0xB8, 0x00, 0x00, 0x00, 0x00, 0xC9, 0xC3, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x55, 0x48, 0x89, 0xE5, 0x48, 0x83, 0xEC, 0x40, 0x48, 0x89, 0x4D, 0x10, 0x48, 0x89, 0x55, 0x18, 0x48, 0x8B, 0x45, 0x10, 0x8B, 0x40, 0x3C, 0x48, 0x98, 0x48, 0x8B, 0x55, 0x10, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x89, 0xC2, 0x48, 0x8B, 0x45, 0x10, 0x48, 0x01, 0xD0, 0x48, 0x89, 0x45, 0xF0, 0xC7, 0x45, 0xFC, 0x00, 0x00, 0x00, 0x00, 0xE9, 0x86, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x45, 0xF0, 0x8B, 0x40, 0x20, 0x89, 0xC2, 0x8B, 0x45, 0xFC, 0x48, 0xC1, 0xE0, 0x02, 0x48, 0x01, 0xC2, 0x48, 0x8B, 0x45, 0x10, 0x48, 0x01, 0xD0, 0x8B, 0x00, 0x48, 0x98, 0x48, 0x8B, 0x55, 0x10, 0x48, 0x01, 0xD0, 0x48, 0x89, 0x45, 0xE8, 0x48, 0x8B, 0x55, 0x18, 0x48, 0x8B, 0x45, 0xE8, 0x48, 0x89, 0xC1, 0xE8, 0x38, 0x01, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x45, 0x48, 0x8B, 0x55, 0x10, 0x48, 0x8B, 0x45, 0xF0, 0x8B, 0x40, 0x1C, 0x41, 0x89, 0xC0, 0x48, 0x8B, 0x45, 0xF0, 0x8B, 0x40, 0x24, 0x89, 0xC1, 0x8B, 0x45, 0xFC, 0x48, 0x01, 0xC0, 0x48, 0x01, 0xC1, 0x48, 0x8B, 0x45, 0x10, 0x48, 0x01, 0xC8, 0x0F, 0xB7, 0x00, 0x0F, 0xB7, 0xC0, 0x48, 0xC1, 0xE0, 0x02, 0x49, 0x8D, 0x0C, 0x00, 0x48, 0x8B, 0x45, 0x10, 0x48, 0x01, 0xC8, 0x8B, 0x00, 0x48, 0x98, 0x48, 0x01, 0xD0, 0xEB, 0x19, 0x83, 0x45, 0xFC, 0x01, 0x48, 0x8B, 0x45, 0xF0, 0x8B, 0x40, 0x18, 0x39, 0x45, 0xFC, 0x0F, 0x82, 0x6A, 0xFF, 0xFF, 0xFF, 0xB8, 0x00, 0x00, 0x00, 0x00, 0xC9, 0xC3, 0x90, 0x90, 0x90, 0x90, 0x55, 0x48, 0x89, 0xE5, 0x48, 0x83, 0xEC, 0x10, 0x48, 0x89, 0x4D, 0x10, 0x48, 0x89, 0x55, 0x18, 0xEB, 0x7D, 0x48, 0x8B, 0x45, 0x10, 0x0F, 0xB7, 0x00, 0x66, 0x83, 0xF8, 0x40, 0x76, 0x19, 0x48, 0x8B, 0x45, 0x10, 0x0F, 0xB7, 0x00, 0x66, 0x83, 0xF8, 0x5A, 0x77, 0x0C, 0x48, 0x8B, 0x45, 0x10, 0x0F, 0xB7, 0x00, 0x83, 0xC0, 0x20, 0xEB, 0x07, 0x48, 0x8B, 0x45, 0x10, 0x0F, 0xB7, 0x00, 0x66, 0x89, 0x45, 0xFE, 0x48, 0x8B, 0x45, 0x18, 0x0F, 0xB7, 0x00, 0x66, 0x83, 0xF8, 0x40, 0x76, 0x19, 0x48, 0x8B, 0x45, 0x18, 0x0F, 0xB7, 0x00, 0x66, 0x83, 0xF8, 0x5A, 0x77, 0x0C, 0x48, 0x8B, 0x45, 0x18, 0x0F, 0xB7, 0x00, 0x83, 0xC0, 0x20, 0xEB, 0x07, 0x48, 0x8B, 0x45, 0x18, 0x0F, 0xB7, 0x00, 0x66, 0x89, 0x45, 0xFC, 0x0F, 0xB7, 0x45, 0xFE, 0x66, 0x3B, 0x45, 0xFC, 0x74, 0x07, 0xB8, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x3D, 0x48, 0x83, 0x45, 0x10, 0x02, 0x48, 0x83, 0x45, 0x18, 0x02, 0x48, 0x8B, 0x45, 0x10, 0x0F, 0xB7, 0x00, 0x66, 0x85, 0xC0, 0x74, 0x10, 0x48, 0x8B, 0x45, 0x18, 0x0F, 0xB7, 0x00, 0x66, 0x85, 0xC0, 0x0F, 0x85, 0x67, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x45, 0x10, 0x0F, 0xB7, 0x10, 0x48, 0x8B, 0x45, 0x18, 0x0F, 0xB7, 0x00, 0x66, 0x39, 0xC2, 0x0F, 0x94, 0xC0, 0x0F, 0xB6, 0xC0, 0xC9, 0xC3, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x55, 0x48, 0x89, 0xE5, 0x48, 0x83, 0xEC, 0x10, 0x48, 0x89, 0x4D, 0x10, 0x48, 0x89, 0x55, 0x18, 0xEB, 0x72, 0x48, 0x8B, 0x45, 0x10, 0x0F, 0xB6, 0x00, 0x3C, 0x40, 0x7E, 0x17, 0x48, 0x8B, 0x45, 0x10, 0x0F, 0xB6, 0x00, 0x3C, 0x5A, 0x7F, 0x0C, 0x48, 0x8B, 0x45, 0x10, 0x0F, 0xB6, 0x00, 0x83, 0xC0, 0x20, 0xEB, 0x07, 0x48, 0x8B, 0x45, 0x10, 0x0F, 0xB6, 0x00, 0x88, 0x45, 0xFF, 0x48, 0x8B, 0x45, 0x18, 0x0F, 0xB6, 0x00, 0x3C, 0x40, 0x7E, 0x17, 0x48, 0x8B, 0x45, 0x18, 0x0F, 0xB6, 0x00, 0x3C, 0x5A, 0x7F, 0x0C, 0x48, 0x8B, 0x45, 0x18, 0x0F, 0xB6, 0x00, 0x83, 0xC0, 0x20, 0xEB, 0x07, 0x48, 0x8B, 0x45, 0x18, 0x0F, 0xB6, 0x00, 0x88, 0x45, 0xFE, 0x0F, 0xB6, 0x45, 0xFF, 0x3A, 0x45, 0xFE, 0x74, 0x07, 0xB8, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x3A, 0x48, 0x83, 0x45, 0x10, 0x01, 0x48, 0x83, 0x45, 0x18, 0x01, 0x48, 0x8B, 0x45, 0x10, 0x0F, 0xB6, 0x00, 0x84, 0xC0, 0x74, 0x0F, 0x48, 0x8B, 0x45, 0x18, 0x0F, 0xB6, 0x00, 0x84, 0xC0, 0x0F, 0x85, 0x74, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x45, 0x10, 0x0F, 0xB6, 0x10, 0x48, 0x8B, 0x45, 0x18, 0x0F, 0xB6, 0x00, 0x38, 0xC2, 0x0F, 0x94, 0xC0, 0x0F, 0xB6, 0xC0, 0xC9, 0xC3, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x4B, 0x00, 0x65, 0x00, 0x72, 0x00, 0x6E, 0x00, 0x65, 0x00, 0x6C, 0x00, 0x33, 0x00, 0x32, 0x00, 0x2E, 0x00, 0x64, 0x00, 0x6C, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x57, 0x72, 0x69, 0x74, 0x65, 0x43, 0x6F, 0x6E, 0x73, 0x6F, 0x6C, 0x65, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

        fixed (byte* pCode = code)
        {
            IntPtr g_codeAddress = (IntPtr)pCode;
            UIntPtr g_codeSize = (UIntPtr)code.Length;

            // Initialize emulator (sets up VEH)
            VectoredExceptionHandler.Initialize(g_codeAddress, g_codeSize);

            int size = Marshal.SizeOf<CONTEXT>();
            CONTEXT* pCtx = (CONTEXT*)Marshal.AllocHGlobal(size);
            CONTEXT ctx = Marshal.PtrToStructure<CONTEXT>((IntPtr)pCtx);
            pCtx->ContextFlags = CONTEXT_DEBUG_REGISTERS;
            if (!GetThreadContext(GetCurrentThread(), (IntPtr)pCtx))
            {
                Console.WriteLine("GetThreadContext failed with error: " + GetLastError());
                return;
            }
            // Set hardware breakpoint at start of our code
            pCtx->Dr0 = (ulong)g_codeAddress;
            pCtx->Dr7 = 0x1ul; // Enable DR0 (execute breakpoint, 1-byte length)

            if (!SetThreadContext(GetCurrentThread(), (IntPtr)pCtx))
            {
                Console.WriteLine("SetThreadContext failed.");
                return;
            }

            //PRINT_CONTEXT(&ctx);
            //DBG_Pause("HWBPs armed — ready to execute");

            // --- Simulate executing code that triggers HWBP ---
            ((delegate* unmanaged<void>)pCode)(); // This will trigger VEH
            Console.WriteLine("Returned from code execution.");
        }
    }
    static int HexValue(char c)
    {
        if (c >= '0' && c <= '9') return c - '0';
        if (c >= 'a' && c <= 'f') return 10 + (c - 'a');
        if (c >= 'A' && c <= 'F') return 10 + (c - 'A');
        throw new ArgumentException($"Invalid hex digit: {c}");
    }
    static byte[] ParseCStyleEscapes(string s)
    {
        if (s == null) throw new ArgumentNullException(nameof(s));
        var outBytes = new System.Collections.Generic.List<byte>(s.Length);

        for (int i = 0; i < s.Length; ++i)
        {
            char c = s[i];
            if (c != '\\')
            {
                // Normal character: append its byte value (ASCII). If you prefer to treat other text differently,
                // modify here (e.g., treat as UTF-8). For raw shellcode input normally only \x.. sequences are used.
                outBytes.Add((byte)c);
                continue;
            }

            // Escape sequence
            if (i + 1 >= s.Length) throw new ArgumentException("Trailing backslash in escape string.");
            char esc = s[++i];

            switch (esc)
            {
                case '\\':
                    outBytes.Add((byte)'\\');
                    break;
                case 'n':
                    outBytes.Add((byte)'\n');
                    break;
                case 'r':
                    outBytes.Add((byte)'\r');
                    break;
                case 't':
                    outBytes.Add((byte)'\t');
                    break;
                case 'x':
                case 'X':
                    {
                        // Expect exactly two hex digits after \x
                        if (i + 2 >= s.Length) throw new ArgumentException(@"\x must be followed by two hex digits.");
                        char h1 = s[++i];
                        char h2 = s[++i];
                        int hi = HexValue(h1);
                        int lo = HexValue(h2);
                        outBytes.Add((byte)((hi << 4) | lo));
                    }
                    break;
                default:
                    // Unknown escape: allow \? or treat as literal esc char + next char.
                    // Here we'll treat as error to avoid ambiguity.
                    throw new ArgumentException($"Unsupported escape sequence: \\{esc}");
            }
        }

        return outBytes.ToArray();
    }
}

